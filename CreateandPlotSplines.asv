%%
%
% DO NOT RUN WITHOUT READING THE "READ ME" FILE FIRST!
%
%%
clear
close all
clc

fprintf(['\n',repmat('=',1, 85),'\n']);
fprintf('Select Data Addresses File\n');
fprintf([repmat('=',1, 85),'\n']);

curr_dir = dir(fullfile(pwd,'\\WayPoints*.txt'));

if (length(curr_dir)>1)
    % Select file
    fprintf('\nPlease select the desired storage file:\n\n');
    fprintf('   0: Abort Operation\n');
    for i = 1:length(curr_dir)
        fprintf('   %i: %s\n',i,curr_dir(i).name);
    end
    
    selected = 0;
    while selected == 0
        selection = input('\nWhich is the desired file?: ');
        if (length(selection) > 1) || (length(selection) == 1 && (selection > length(curr_dir) || mod(selection,1) || selection < 0)) || ~isnumeric(selection)
            fprintf(2, '\nPlease enter only one valid numeric value\n');
        elseif selection ~= 0
            fprintf('\n   Selected: %s\n\n', curr_dir(selection).name);
            selected = 1;
        elseif selection == 0
            fprintf('\nTerminating\n\n');
            return;
        else
            fprintf(2, '\nPlease enter a value\n');
        end
    end
else
    selection = 1;
end

Err_id = system(sprintf('Path_Planner_new.exe Aircraft_X.txt %s', curr_dir(selection).name));

if (Err_id~=0)
    error('%i',Err_id);
end

mis_id = sscanf(curr_dir(selection).name(11:end), '%d');

%%
clear curr_dir selection selected

curr_dir = dir(fullfile(pwd,sprintf('\\Splines_%02d_*.txt',mis_id)));

if (length(curr_dir)>1)

    fprintf(['\n',repmat('=',1, 85),'\n']);
    fprintf('Select Data Addresses File\n');
    fprintf([repmat('=',1, 85),'\n']);
    
    % Select file
    fprintf('\nPlease select the desired storage file:\n\n');
    fprintf('   0: Abort Operation\n');
    for i = 1:length(curr_dir)
        fprintf('   %i: %s\n',i,curr_dir(i).name);
    end
    
    selected = 0;
    while selected == 0
        selection = input('\nWhich is the desired file?: ');
        if (length(selection) > 1) || (length(selection) == 1 && (selection > length(curr_dir) || mod(selection,1) || selection < 0)) || ~isnumeric(selection)
            fprintf(2, '\nPlease enter only one valid numeric value\n');
        elseif selection ~= 0
            fprintf('\n   Selected: %s\n\n', curr_dir(selection).name);
            selected = 1;
        elseif selection == 0
            fprintf('\nTerminating\n\n');
            return;
        else
            fprintf(2, '\nPlease enter a value\n');
        end
    end
else
    selection = 1;
end

%%
Splines = importdata(sprintf('%s', curr_dir(selection).name), ' ', 1);

n_Splines = size(Splines.data,1);

%% Extraction of loop for Velan

XCoeff      = Splines.data(:, 8:11);

[v, w] = unique( XCoeff(:,1), 'stable' );
duplicate_indices = setdiff( 1:numel(XCoeff(:,1)), w );

min_idx = duplicate_indices(1);

j = 13; % for flat 8s
%j = 17; % for non-flat 8s

XCoeff      = Splines.data(min_idx:(min_idx+j), 8:11);
YCoeff      = Splines.data(min_idx:(min_idx+j),12:15);
ZCoeff      = Splines.data(min_idx:(min_idx+j),16:19);

Mission.Coeffs4      = Splines.data(min_idx:(min_idx+j),20:23);
Mission.Type4       = Splines.data(min_idx:(min_idx+j),2);
Mission.ExitValue   = Splines.data(min_idx:(min_idx+j),7);
Mission.ExitCond    = 0*Splines.data(min_idx:(min_idx+j),7);
Mission.UTMLong     = Splines.data(min_idx:(min_idx+j),3);
Mission.UTMArea     = Splines.data(min_idx:(min_idx+j),4);
Mission.SpLength    = Splines.data(min_idx:(min_idx+j),7);
Mission.SplineIndex = [1:j+1]';
Mission.CoeffsXYZ   = [XCoeff, YCoeff, ZCoeff];

% clear Splines i n_Splines variable x y z Err_id curr_dir mis_id selection

save Splines_Mengen_Eight Mission;


%%

figure()
hold on
grid on
axis equal
fontSize = 18;

% Define a custom set of distinct colors (you can adjust these)
customColors = [
    0 0 1;   % Blue
    0 1 0;   % Green
    1 0 0;   % Red
    0.5 0.5 0.5;   % Grey
    1 0 1;   % Magenta
    0 1 1;   % Cyan
    0.5 0 0.5; % Purple
    0.9 0.5 0; % Orange
    0.3 0.75 0.93; % Sky Blue
    0.75 0.5 0.75; % Violet
    1 0.5 0.5; % Light Red
    0.4 0.8 0.4; % Light Green
    0.6 0.3 0.3 % Brownish Red
];

numColors = size(customColors, 1);

% Define sphere properties (for start point) and lines
radius = 20;  % Sphere for the start point
line_length = 50;  % Length of separating lines between splines
[X_sphere, Y_sphere, Z_sphere] = sphere(20);  % Create a unit sphere with 20 subdivisions for the starting point
lat = [];
lon = [];

% Loop over each spline segment
for i = min_idx:(min_idx+j-2)
    
    variable = [0:Splines.data(i,7) Splines.data(i,7)];
    
    % Compute x, y, z values
    x = Splines.data(i, 8) + Splines.data(i, 9).*variable + Splines.data(i,10).*(variable.^2) + Splines.data(i,11).*(variable.^3) + 6378137*(pi/180)*(Splines.data(i, 3) - 60)*3;
    y = Splines.data(i,12) + Splines.data(i,13).*variable + Splines.data(i,14).*(variable.^2) + Splines.data(i,15).*(variable.^3) + 1000000*(Splines.data(i, 4) - 10);
    z = Splines.data(i,16) + Splines.data(i,17).*variable + Splines.data(i,18).*(variable.^2) + Splines.data(i,19).*(variable.^3);
    
    % Get color for the current spline from the custom colors array
    colorIdx = mod(i - min_idx, numColors) + 1; % Cycle through the colors if splines exceed the number of colors
    color = customColors(colorIdx, :);
    
    % Plot a short line at the start of the spline (instead of the black ball)
    x_center = Splines.data(i, 8) + 6378137*(pi/180)*(Splines.data(i, 3) - 60)*3;
    y_center = Splines.data(i,12) + 1000000*(Splines.data(i, 4) - 10);
    z_center = Splines.data(i,16);
    
    % Short line to separate the splines
    plot3([x_center, x_center], [y_center, y_center], [z_center, z_center + line_length], 'k', 'LineWidth', 3);

    % Plot the spline
    plot3(x, y, z, 'Color', color, 'LineWidth', 4)
    
    % Add text to mark each spline
    text(x_center - 15, y_center + 25, z_center + line_length, sprintf('%d', i-min_idx+1), ...
     'FontSize', fontSize, 'Color', color, 'FontWeight', 'bold', 'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom');

    % Convert [x, y] in [lat,lon]    
    [latitide, longitude] = UTM2LatLong(x, y, 15, 'N'); 
    lat = [lat; latitide];
    lon = [lon; longitude];
end
xlabel('$x$ [m]', 'FontSize', fontSize, 'Interpreter', 'latex');
ylabel('$y$ [m]', 'FontSize', fontSize, 'Interpreter', 'latex');
zlabel('$z$ [m]', 'FontSize', fontSize, 'Interpreter', 'latex');
title('UTM Coordinate System', 'FontSize', fontSize + 2)
set(gca, 'FontSize', fontSize); % Apply font size

% Plot the start point using Mission.CoeffsXYZ (using the first row)
x_start = Mission.CoeffsXYZ(1, 1) + 6378137*(pi/180)*(Splines.data(i, 3) - 60)*3;  % X coordinate
y_start = Mission.CoeffsXYZ(1, 5) + 1000000*(Splines.data(i, 4) - 10);  % Y coordinate
z_start = Mission.CoeffsXYZ(1, 9);  % Z coordinate

% Plot the start point as a large black sphere
surf(radius*X_sphere + x_start, radius*Y_sphere + y_start, radius*Z_sphere + z_start, ...
     'FaceColor', 'k', 'EdgeColor', 'none');  % 'k' for black color (start point)

% Move the text a bit right from the starting point
% text(x_start + 50, y_start + 80, z_start, 'Start Point', ...
%      'FontSize', fontSize - 2, 'Color', 'k', 'FontWeight', 'bold', 'HorizontalAlignment', 'left');

hold off

% 绘制2D飞行路径轨迹
figure;
              
geoplot(lat, lon, '-b', 'LineWidth', 2);
geobasemap streets;  % 可以选择不同的地图样式，如 'satellite', 'streets', 'topographic'
title('2D Flight Trajectory');

function [lat, lon] = UTM2LatLong(easting, northing, zoneNumber, hemisphere)
    % UTM2LatLong converts UTM coordinates to latitude and longitude.
    %
    % Inputs:
    %   easting    - Easting in meters (vector)
    %   northing   - Northing in meters (vector)
    %   zoneNumber - UTM zone number (scalar or vector matching the size of easting/northing)
    %   hemisphere - 'N' or 'S' (scalar or vector matching the size of easting/northing)
    %
    % Outputs:
    %   lat - Latitude in decimal degrees (vector)
    %   lon - Longitude in decimal degrees (vector)
    
    % WGS84 ellipsoid constants
    a = 6378137.0; % Semi-major axis
    e = 0.0818191908; % Eccentricity
    k0 = 0.9996; % Scale factor
    
    % Ensure inputs are column vectors
    easting = easting(:);
    northing = northing(:);
    
    % Check if zoneNumber and hemisphere are scalars, and replicate if necessary
    if isscalar(zoneNumber)
        zoneNumber = repmat(zoneNumber, size(easting));
    else
        zoneNumber = zoneNumber(:);
    end
    
    if ischar(hemisphere) || isstring(hemisphere)
        hemisphere = repmat(hemisphere, size(easting));
    else
        hemisphere = hemisphere(:);
    end
    
    % Remove false easting
    x = easting - 500000.0;
    
    % Remove false northing for southern hemisphere
    isSouthernHemisphere = upper(hemisphere) == 'S';
    y = northing;
    y(isSouthernHemisphere) = y(isSouthernHemisphere) - 10000000.0;
    
    % Calculate the meridional arc
    M = y ./ k0;
    
    % Calculate the footprint latitude
    e1 = (1 - sqrt(1 - e^2)) / (1 + sqrt(1 - e^2));
    mu = M ./ (a * (1 - e^2 / 4 - 3 * e^4 / 64 - 5 * e^6 / 256));
    
    % Calculate latitude-related parameters
    J1 = (3 * e1 / 2 - 27 * e1^3 / 32);
    J2 = (21 * e1^2 / 16 - 55 * e1^4 / 32);
    J3 = (151 * e1^3 / 96);
    J4 = (1097 * e1^4 / 512);
    
    % Footprint latitude
    fp = mu + J1 .* sin(2 .* mu) + J2 .* sin(4 .* mu) + J3 .* sin(6 .* mu) + J4 .* sin(8 .* mu);
    
    % Calculate latitude and longitude
    e2 = e^2 / (1 - e^2);
    C1 = e2 .* cos(fp).^2;
    T1 = tan(fp).^2;
    R1 = a * (1 - e^2) ./ (1 - e^2 .* sin(fp).^2).^(3 / 2);
    N1 = a ./ sqrt(1 - e^2 .* sin(fp).^2);
    
    D = x ./ (N1 .* k0);
    
    % Latitude calculations
    Q1 = N1 .* tan(fp) ./ R1;
    Q2 = D.^2 / 2;
    Q3 = (5 + 3 .* T1 + 10 .* C1 - 4 .* C1.^2 - 9 .* e2) .* D.^4 / 24;
    Q4 = (61 + 90 .* T1 + 298 .* C1 + 45 .* T1.^2 - 252 .* e2 - 3 .* C1.^2) .* D.^6 / 720;
    lat_rad = fp - Q1 .* (Q2 - Q3 + Q4);
    
    % Longitude calculations
    Q5 = D;
    Q6 = (1 + 2 .* T1 + C1) .* D.^3 / 6;
    Q7 = (5 - 2 .* C1 + 28 .* T1 - 3 .* C1.^2 + 8 .* e2 + 24 .* T1.^2) .* D.^5 / 120;
    lon_rad = (Q5 - Q6 + Q7) ./ cos(fp);
    
    % Convert radians to degrees
    lat = rad2deg(lat_rad);
    lon = rad2deg(lon_rad) + (zoneNumber - 1) * 6 - 180 + 3;

end












